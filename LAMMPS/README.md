# MADna-LAMMPS
LAMMPS implementation of MADna, a coarse-grained model for sequence-dependent elasticity and conformation of DNA (https://doi.org/10.1101/2021.12.02.470889, which is also the reference which should be cited in any work employing MADna). **In order to run MADna within LAMMPS, the latter has to be built with the packages EXTRA-MOLECULE and EXTRA-PAIR**. Morover, for application of torque according to the scripts provided in the folder "additional" (see below), also the package EXTRA-FIX is needed. The code has been tested for the version 29 Sep 2021.

There are two folders, for which more details are provided below:
- **Initialization**: This folder contains all the scripts needed to create the topology and initial configuration of a double-stranded DNA molecule from its sequence
- **Analysis**: This folder contains analysis scripts to determine geometrical parameters of DNA (grooves, hrise, htwist, diameter, crookedness, extension) and the tangent-tangent correlation function needed to compute the persistence length

## Initialization
This folder contains scripts for generation of MADna topology and initial configuration for a double-stranded DNA molecule in LAMMPS format. To execute the scripts, **python3 is needed with libraries sys, os, numpy, copy**.  
From the user's perspective, the only relevant script is **Initialization.py**, which imports the other ones as libraries (further useful scripts are found in the subfolder "additional", as commented below). Usage of the script is pretty straightforward:
```
Initialization/Initialization.py sequence folder ionic_strength temperature
```
Hence, the script needs four inputs:
- sequence: the sequence of the leading strand in the 5'-3' direction
- folder: the folder where the various files will be stored (if the folder does not exist, it is created automatically)
- ionic strength: the ionic strength of the solution in mM
- temperature: the temperature of the system in K

For instance, the following command
```
Initialization/Initialization.py CAAGATGC mySim/initialization 150 300
```
creates the files needed to simulate a DNA molecule with sequence 5'-CAAGATGC-3' (corresponding to 5'-GCATCTTG-3' on the other strand) embedded in a solution containing 150 mM of salt and at temperature 300 K, and stores the files in the folder mySim/initialization

The script generates four files:
- **sequence.dat** contains the chosen sequence as a simple text
- **stdump.lammpstrj** contains the initial coordinates of the beads within the molecule, written in LAMMPS format
- **chain.dat** contains the topology of the molecule in LAMMPS format (units correspond to the "real" format in LAMMPS)
- **lammps.in** is a minimal script for simulation of the system in LAMMPS, where the dynamics is run for 10 ns with a dump every 10 ps. Note that a group of commented lines indicates the point of the script where additional features can be added (see below)

Additionally, in the subfolder "additional" there are two other useful scripts to implement a pulling force and a torque:
- **pulling_torque.py** generates the code to apply a pulling force and a torque in the z direction, according to the protocol employed in https://doi.org/10.1101/2021.12.02.470889 to generate Fig.6 (see section "Methods/Molecular dynamics Simulations/Stretch-torsion simulations"). Its usage is:
```
Initialization/additional/pulling_torque.py sequence force torque
```
where the force is in pN and the torque in pN·nm. The script gives as output the chunk of code to be added to lammps.in (as generated by initialization.py). For instance, running
```
Initialization/additional/pulling_torque.py CAAGATGC 3 7
```
generates the following patch, which applies a pulling force of 3 pN and a torque of 7 pN·nm to the molecule:
```
compute xu all property/atom xu
compute yu all property/atom yu
variable dx equal -0.5*(c_xu[19]+c_xu[27])
variable dy equal -0.5*(c_yu[19]+c_yu[27])
thermo_style custom v_dx v_dy
run 0
displace_atoms all move v_dx v_dy 0 units box
thermo_style one
group blockA1 id <= 5
group blockA2 id >= 42
group blockA union blockA1 blockA2
group fB id 19 27
group torque id <> 19 27
fix tetherA blockA spring/self 100 xyz
variable fxB equal -100*(c_xu[19]+c_xu[27])
variable fyB equal -100*(c_yu[19]+c_yu[27])
fix fB fB addforce v_fxB v_fyB 0.0216
fix torque torque addtorque 0 0 1.0070
```
- **pulling_AMBER_protocol.py** generates the code to apply a pulling force directed along the end-to-end vector of the DNA molecule, see Fig.4 and Fig.5 in  https://doi.org/10.1101/2021.12.02.470889 and section "Methods/Molecular dynamics Simulations/Benchmark simulations". Its usage is:
```
Initialization/additional/pulling_AMBER_protocol.py sequence force
```
where the force is in pN. For instance, running
```
Initialization/additional/pulling_AMBER_protocol.py CAAGATGC 3
```
generates the following patch, which applies a pulling force of 3 pN:
```
compute xu all property/atom xu
compute yu all property/atom yu
compute zu all property/atom zu
variable xcmA equal 0.5*(c_xu[4]+c_xu[42])
variable ycmA equal 0.5*(c_yu[4]+c_yu[42])
variable zcmA equal 0.5*(c_zu[4]+c_zu[42])
variable xcmB equal 0.5*(c_xu[19]+c_xu[27])
variable ycmB equal 0.5*(c_yu[19]+c_yu[27])
variable zcmB equal 0.5*(c_zu[19]+c_zu[27])
variable dr equal sqrt((v_xcmB-v_xcmA)*(v_xcmB-v_xcmA)+(v_ycmB-v_ycmA)*(v_ycmB-v_ycmA)+(v_zcmB-v_zcmA)*(v_zcmB-v_zcmA))
variable fxA equal -(v_xcmB-v_xcmA)*0.0216/v_dr
variable fyA equal -(v_ycmB-v_ycmA)*0.0216/v_dr
variable fzA equal -(v_zcmB-v_zcmA)*0.0216/v_dr
variable fxB equal -v_fxA
variable fyB equal -v_fyA
variable fzB equal -v_fzA
group fA id 4 42
group fB id 4 42
fix fA fA addforce v_fxA v_fyA v_fzA
fix fB fB addforce v_fxB v_fyB v_fzB
```
## Analysis
This folder contains useful scripts to analyze the output of LAMMPS simulations based on MADna. **The codes need a c++ compiler and the GNU Scientific Library (gsl) installed in your system**. They have been tested using g++ 11.2.0 and gsl 2.7.

Four scripts are currently available:
### 1) Compute_Ext_CumulateTwist_Crookedness.cpp
It computes the extension, total twist and crookedness of a DNA fragment. In its current stage, this code works properly on molecules composed of roughly 20 base pairs, since the helical axis is defined globally for the whole molecule. Its usage is as follows (it is assumed that the compiled executable is named as the script without the .cpp extension)
```
Compute_Ext_CumulateTwist_Crookedness trajectory seed start stop
```
where ```trajectory``` is the trajectory in LAMMPS format with fields ```id type xu yu zu``` (the format set in the script "lammps.in"); ```seed``` is a positive integer to seed the gsl random number generator (needed for the determination of the helical axis); ```start``` and ```stop``` are the first and last nucleotides of the fragment to be examined. For instance, the following command
```
Compute_Ext_CumulateTwist_Crookedness dump.lammpstrj 1311 5 14
```
analyzes the fragment within nucleotides 5 and 14 (included) for the trajectory ```dump.lammpstrj```. The output is in four columns, giving for each frame the timestep, extension (nm), cumulate twist (rad) and crookedness.

### 2) ComputeHelicalParameters_global.cpp
It computes the various geometrical features of the molecule under inspection. Its usage is as follows:
```
ComputeHelicalParameters_global trajectory seed prefix
```
where ```trajectory``` is the trajectory in LAMMPS format with fields ```id type xu yu zu``` (the format set in the script "lammps.in"); ```seed``` is a positive integer to seed the gsl random number generator (needed for the determination of the helical axis); ```prefix``` is a label to prepend in the names of the output files. For instance, the following command
```
ComputeHelicalParameters_global dump.lammpstrj 2358 hel
```
analyzes the trajectory ```dump.lammpstrj``` and saves the results in a series of files with prefix ```hel```. Particularly, the following files are created:
- *hel_diameter*: two columns containing timestep and global diameter (nm); at the current stage it is meaningful only for molecules composed of roughly 20 base pairs.
- *hel_hrise*: Lseq columns (where Lseq is the length of the sequence) containing timestep (column 1) and hrise for the Lseq-1 steps (nm); at the current stage it is meaningful only for molecules composed of roughly 20 base pairs
- *hel_htwist*: Lseq columns containing timestep (column 1) and htwist for the Lseq-1 steps (deg); at the current stage it is meaningful only for molecules composed of roughly 20 base pairs
- *hel_major_groove_width, hel_minor_groove_width, hel_major_groove_depth, hel_minor_groove_depth*: Lseq+1 columns containing timestep (column 1) and the groove feature corresponding to the filename for all the base pairs (nm); close to the ends, groove geometry might not be determined, in which case a large negative number is displayed (-1e9)
Note that it is possible to provide a prefix containing a path (e.g. a prefix equal to "mySim/hel" will create files "mySim/hel_diameter" and so on). However, the folders within the path must already exist.

### 3) Compute_Ext_CumulateTwist_zaxis.cpp
It computes the extension and total twist of a DNA fragment in the z direction. Its usage is as follows:
```
Compute_Ext_CumulateTwist_zaxis trajectory start stop
```
where ```trajectory``` is the trajectory in LAMMPS format with fields ```id type xu yu zu``` (the format set in the script "lammps.in"); ```start``` and ```stop``` are the first and last nucleotides of the fragment to be examined. For instance, the following command
```
Compute_Ext_CumulateTwist_zaxis dump.lammpstrj 5 14
```
analyzes the fragment within nucleotides 5 and 14 (included) for the trajectory ```dump.lammpstrj```. The output is in three columns, giving for each frame the timestep, extension (nm) and cumulate twist (rad). 

### 4) ComputeCorrelationFunction.cpp
It computes the tangent-tangent correlation function of a DNA molecule according to the "sugars" definition in https://doi.org/10.1101/2021.12.02.470889. Its usage is as follows:
```
ComputeCorrelationFunction trajectory s0 start stop output
```
where ```trajectory``` is the trajectory in LAMMPS format with fields ```id type xu yu zu``` (the format set in the script "lammps.in"); ```s0``` is the number of base pairs separating two consecutive points for the computation of the correlation function; ```start``` and ```stop``` are the first and last nucleotides of the fragment to be examined; ```output``` is the name of the output file. For instance, the following command
```
ComputeCorrelationFunction dump.lammpstrj 10 30 60 myCorrelation
```
analyzes the trajectory ```dump.lammpstrj``` considering the vectors joining points separated by 10 base pairs for the fragment including base pairs 30 to 60. The results are written in two files:
- myCorrelation has n+1 columns, where n is the number of vectors encompassing the fragment under study; the first column is the timestep, the rest are the average cosines of the angles formed by vectors separated by multiples of s0. In the present example s0=10, hence the cosines correspond to vectors separated by 0 base pairs (column 2), 10 base pairs (column 3), 20 base pairs (column 4), 30 base pairs (column 5).
- myCorrelation_step provides a single number, corresponding to the average contour length corresponding to s0 (nm). In this case, s0=10 will result is a value slightly larger than 3 nm. 
